{"version":3,"sources":["PathfindingVisualizer.module.scss","SearchingAlgorithms/BFS.js","util.js","PathfindingVisualizer.js","index.js"],"names":["module","exports","takeSnapshot","randomIntFromInterval","min","max","Math","floor","random","gridNeighbors","i","j","rows","cols","possibleNeighbors","neighbors","k","length","push","changeValue","dict","key","newValue","value","search","props","origin_c","goal_c","nodes","x1","ROWS","y1","COLUMNS","x2","y2","node","ORIGIN","GOAL","coor1","coor2","sameCoordinates","_c","frontier","explored","traverseFrom","shift","EXPLORED","neighbor","includes","goalTest","path","curr","PATH","FRONTIER","BFS","Node","color","useState","active","className","styles","nodeActive","style","background","Board","this","row","columns","renderNode","React","Component","PathfindingVisualizer","state","generateGrid","animating","history","clearHistory","timeoutIDArray","clearTimeouts","clearTimeout","resumePoint","newDict","copyDict","e","console","error","displayState","setState","animateHistory","startPoint","count","timeoutID","setTimeout","goToState","test","onClick","doSearch","grid","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.aa2e4277.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"PathfindingVisualizer_node__19mGv\",\"nodeActive\":\"PathfindingVisualizer_nodeActive__2NUBo\",\"row\":\"PathfindingVisualizer_row__AX94S\",\"test\":\"PathfindingVisualizer_test__Rcse7\"};","import { ORIGIN, GOAL, FRONTIER, EXPLORED, PATH, ROWS, COLUMNS } from \"../PathfindingVisualizer\";\nimport { sameCoordinates, changeValue, randomIntFromInterval } from \"../util\";\nvar takeSnapshot;\n\nexport function search(props) {\n    const nodes = props.nodes;\n    takeSnapshot = props.takeSnapshot;\n    let origin_c;\n    let goal_c;\n\n    let x1 = randomIntFromInterval(0, ROWS-1);\n    let y1 = randomIntFromInterval(0, COLUMNS-1);\n    let x2 = randomIntFromInterval(0, ROWS-1);\n    let y2 = randomIntFromInterval(0, COLUMNS-1);\n    // Hard code for testing purposes\n    nodes[[x1,y1]].value = ORIGIN;\n    nodes[[x2,y2]].value = GOAL;\n    // ------------------------------\n\n    for (var node in nodes) {\n        if (nodes[node].value === ORIGIN) {\n            origin_c = node;\n        }\n        if (nodes[node].value === GOAL) {\n            goal_c = node;\n        }\n    }\n    if (origin_c && goal_c) {\n        BFS(nodes, origin_c, goal_c);\n    }\n}\n\nfunction BFS(nodes, origin_c, goal_c) {\n    takeSnapshot(nodes);\n\n    if (sameCoordinates(origin_c, goal_c)) {\n        return [origin_c];\n    }\n    var frontier = [], explored = [], traverseFrom = {};\n    frontier.push(\"\" + origin_c);\n    traverseFrom[\"\" + origin_c] = null;\n    takeSnapshot(nodes);\n\n    var _c, node;\n    while (true) {\n        // Failed to find the goal\n        if (!frontier.length) {\n            return [];\n        }\n        _c = frontier[0];\n        explored.push(_c);\n        frontier.shift();\n        if (_c !== \"\" + origin_c) {\n            changeValue(nodes, _c, EXPLORED);\n        }\n        takeSnapshot(nodes);\n\n        node = nodes[_c];\n        for (let i = 0; i < node.neighbors.length; i++) {\n            let neighbor = \"\" + node.neighbors[i];\n            if (!frontier.includes(neighbor) && !explored.includes(neighbor)) {\n                if (goalTest(nodes[neighbor])) {\n                    traverseFrom[neighbor] = _c;\n                    let path = [neighbor];\n                    let curr = neighbor;\n                    while (curr) {\n                        path.push(traverseFrom[curr]);\n                        curr = traverseFrom[curr];\n                        if (curr) {\n                            if (curr !== \"\" + origin_c) {\n                                changeValue(nodes, curr, PATH);\n                            }\n                            takeSnapshot(nodes);\n                        }\n                    }\n                    \n                    return path;\n                }\n                frontier.push(\"\" + neighbor);\n                traverseFrom[neighbor] = _c;\n                // console.log(traverseFrom);\n                changeValue(nodes, neighbor, FRONTIER);\n                takeSnapshot(nodes);\n            }\n        }\n    }\n}\n\nfunction goalTest(node) {\n    if (node.value === GOAL) { return true; }\n    return false;\n}\n","// Generates a random integer within the given interval, exclusive of max.r\nexport function randomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max-min+1) + min);\n}\n\nexport function gridNeighbors(i, j, rows, cols) {\n    // const possibleNeighbors = [[i-1, j-1], [i-1, j], [i-1, j+1], [i, j-1], [i, j+1], [i+1, j-1], [i+1, j], [i+1, j+1]];\n    const possibleNeighbors = [[i-1, j], [i, j-1], [i, j+1], [i+1, j]];\n    var neighbors = [];\n    for (let k = 0; k < possibleNeighbors.length; k++) {\n        if (0 <= possibleNeighbors[k][0] && possibleNeighbors[k][0] < rows) {\n            if (0 <= possibleNeighbors[k][1] && possibleNeighbors[k][1] < cols) {\n                neighbors.push(possibleNeighbors[k]);\n            }\n        }\n    }\n    return neighbors;\n}\n\nexport function sameCoordinates(coor1, coor2) {\n    return (coor1[0]===coor2[0] && coor1[1]===coor2[1]);\n}\n\nexport function changeValue(dict, key, newValue) {\n    dict[key].value = newValue;\n}","import React from 'react';\nimport styles from \"./PathfindingVisualizer.module.scss\";\nimport { useState } from 'react';\nimport { Button } from '@material-ui/core';\nimport { search as BFS } from \"./SearchingAlgorithms/BFS\";\nimport { gridNeighbors } from \"./util\";\n\nexport const ROWS = 15;\nexport const COLUMNS = 38;\n\nexport const GOAL = 0;\nexport const ORIGIN = 1;\nexport const PATH = 2;\nexport const EXPLORED = 3;\nexport const FRONTIER = 4;\n\nconst ANIMATION_TIME = 10;\n\n\nconst Node = (props) => {\n    const [active, setActive] = useState(false);\n\n    const handleClick = () => {\n        props.onClick();\n        setActive(!active);\n    }\n\n    var color;\n    switch (props.value) {\n        case GOAL: color = \"green\"; break;\n        case ORIGIN: color = \"red\"; break;\n        case PATH: color = \"yellow\"; break;\n        case EXPLORED: color = \"purple\"; break;\n        case FRONTIER: color = \"#666\"; break;\n        default: color = \"white\"; break;\n    }\n\n    return (\n        <button \n            className={`${active? styles.nodeActive : styles.node}`} \n            // onClick={handleClick}\n            style={{\n                background: color\n            }}\n        />\n    );\n}\n  \nclass Board extends React.Component {\n    renderNode(i, j, key) {\n        return (\n            <Node \n                value={this.props.nodes[[i,j]].value} \n                // onClick={() => this.props.onClick(i, j)}\n                key={key}\n            />\n        );\n    }\n\n    render() {\n        var rows = [];\n        var key = 0;\n        for (let i = 0; i < this.props.rows; i++) {\n            var row = [];\n            for (let j = 0; j < this.props.columns; j++) {\n                row.push(this.renderNode(i, j, key++));\n            }\n            rows.push(<div className={styles.row} key={i}>{row}</div>);\n        }\n        return (\n            <div className=\"board\">\n                {rows}\n            </div>\n        );\n    }\n}\n\nexport default class PathfindingVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            nodes: generateGrid(ROWS, COLUMNS),\n            rows: ROWS,\n            columns: COLUMNS,\n\n            animating: false,\n        };\n\n        this.search = BFS;\n\n        this.history = [];\n        this.clearHistory = () => {\n            this.history = [];\n        }\n\n        this.timeoutIDArray = [];\n        this.clearTimeouts = () => {\n            for (let i = 0; i < this.timeoutIDArray.length; i++) {\n                clearTimeout(this.timeoutIDArray[i]);\n            }\n            this.timeoutIDArray = [];\n        }\n        this.resumePoint = 0;\n\n        this.takeSnapshot = (dict) => {\n            try {\n                this.history.push(copyDict(dict));\n            } catch (e) {\n                console.error(\"Error: takeSnapshot arguments are not well defined.\\n\", e);\n            }\n        }\n    }\n\n    componentDidMount() {\n    }\n\n    goToState(i) {\n        if (i < this.history.length) {\n            var displayState = this.history[i];\n            this.resumePoint = i;\n            this.setState({\n                nodes: displayState, \n                // highlights: {comparing: comparing}, \n            });\n        }\n    }\n\n    doSearch() {\n        this.clearTimeouts();\n        this.clearHistory();\n        var nodes = generateGrid(ROWS, COLUMNS);\n        this.search({nodes: nodes, takeSnapshot: this.takeSnapshot});\n        this.animateHistory(0);\n    }\n\n    animateHistory(startPoint) {\n        if (!startPoint) { startPoint = 0; }\n        if (this.startPoint >= this.history.length - 1) {\n            return;\n        }\n        this.setState({animating: true});\n        var pauseTime;\n        var count = 1;\n        for (let i = startPoint; i < this.history.length; i++) {\n            pauseTime = ANIMATION_TIME * count;\n            let timeoutID = setTimeout(() => {\n                this.goToState(i);\n                if (i === this.history.length - 1) { this.setState({animating: false}); }\n            }, pauseTime);\n\n            this.timeoutIDArray.push(timeoutID);\n            count++;\n        }\n    }\n\n    // handleClick(i, j) {\n    //     var grid = this.state.grid.slice();\n    //     grid[i][j] = 1;\n    //     this.setState({grid: grid});\n    // }\n\n    render() {\n        return (\n            <div>\n                <Board nodes={this.state.nodes} rows={this.state.rows} columns={this.state.columns} />\n                <button className={styles.test} onClick={()=>{ this.doSearch()}}>Test</button>\n            </div>\n        );\n    }\n}\n\nfunction generateGrid(rows, cols) {\n    var grid = {};\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            grid[[i,j]] = {\n                value: -1,\n                neighbors: gridNeighbors(i, j, rows, cols)\n            };\n        }\n    }\n    return grid;\n}\n\nfunction copyDict(dict) {\n    var newDict = {};\n    for (var node in dict) {\n        newDict[node] = {\n            value: dict[node].value,\n            // We don't use neighbors.slice() but actually use original neighbors on purpose\n            // because the neighbors of the nodes should stay consistent throughout searching\n            neighbors: dict[node].neighbors\n        }\n    }\n    return newDict;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport PathfindingVisualizer from './PathfindingVisualizer';\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}