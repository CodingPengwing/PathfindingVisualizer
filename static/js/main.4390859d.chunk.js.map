{"version":3,"sources":["PathfindingVisualizer.module.scss","SearchingAlgorithms/BFS.js","util.js","PathfindingVisualizer.js","index.js"],"names":["module","exports","takeSnapshot","gridNeighbors","i","j","rows","cols","possibleNeighbors","neighbors","k","length","push","changeValue","dict","key","newValue","value","search","props","origin_c","goal_c","nodes","node","ORIGIN","GOAL","coor1","coor2","sameCoordinates","_c","frontier","explored","traverseFrom","shift","EXPLORED","neighbor","includes","goalTest","path","curr","PATH","FRONTIER","BFS","Node","color","useState","active","className","styles","nodeActive","style","background","Board","this","row","columns","renderNode","React","Component","PathfindingVisualizer","state","generateGrid","animating","history","clearHistory","timeoutIDArray","clearTimeouts","clearTimeout","resumePoint","newDict","copyDict","e","console","error","displayState","setState","animateHistory","startPoint","count","timeoutID","setTimeout","goToState","test","onClick","doSearch","grid","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4390859d.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"PathfindingVisualizer_node__19mGv\",\"nodeActive\":\"PathfindingVisualizer_nodeActive__2NUBo\",\"row\":\"PathfindingVisualizer_row__AX94S\",\"test\":\"PathfindingVisualizer_test__Rcse7\"};","import { ORIGIN, GOAL, FRONTIER, EXPLORED, PATH } from \"../PathfindingVisualizer\";\nimport { sameCoordinates, changeValue } from \"../util\";\nvar takeSnapshot;\n\nexport function search(props) {\n    const nodes = props.nodes;\n    takeSnapshot = props.takeSnapshot;\n    let origin_c;\n    let goal_c;\n\n    // Hard code for testing purposes\n    nodes[[5,5]].value = ORIGIN;\n    nodes[[14,25]].value = GOAL;\n    // ------------------------------\n\n    for (var node in nodes) {\n        if (nodes[node].value === ORIGIN) {\n            origin_c = node;\n        }\n        if (nodes[node].value === GOAL) {\n            goal_c = node;\n        }\n    }\n    if (origin_c && goal_c) {\n        BFS(nodes, origin_c, goal_c);\n    }\n}\n\nfunction BFS(nodes, origin_c, goal_c) {\n    takeSnapshot(nodes);\n\n    if (sameCoordinates(origin_c, goal_c)) {\n        return [origin_c];\n    }\n    var frontier = [], explored = [], traverseFrom = {};\n    frontier.push(\"\" + origin_c);\n    traverseFrom[\"\" + origin_c] = null;\n    takeSnapshot(nodes);\n\n    var _c, node;\n    while (true) {\n        // Failed to find the goal\n        if (!frontier.length) {\n            return [];\n        }\n        _c = frontier[0];\n        explored.push(_c);\n        frontier.shift();\n        if (_c !== \"\" + origin_c) {\n            changeValue(nodes, _c, EXPLORED);\n        }\n        takeSnapshot(nodes);\n\n        node = nodes[_c];\n        for (let i = 0; i < node.neighbors.length; i++) {\n            let neighbor = \"\" + node.neighbors[i];\n            if (!frontier.includes(neighbor) && !explored.includes(neighbor)) {\n                if (goalTest(nodes[neighbor])) {\n                    traverseFrom[neighbor] = _c;\n                    let path = [neighbor];\n                    let curr = neighbor;\n                    while (curr) {\n                        path.push(traverseFrom[curr]);\n                        curr = traverseFrom[curr];\n                        if (curr) {\n                            changeValue(nodes, curr, PATH);\n                            takeSnapshot(nodes);\n                        }\n                    }\n                    \n                    return path;\n                }\n                frontier.push(\"\" + neighbor);\n                traverseFrom[neighbor] = _c;\n                // console.log(traverseFrom);\n                changeValue(nodes, neighbor, FRONTIER);\n                takeSnapshot(nodes);\n            }\n        }\n    }\n}\n\nfunction goalTest(node) {\n    if (node.value === GOAL) { return true; }\n    return false;\n}\n","export function gridNeighbors(i, j, rows, cols) {\n    // const possibleNeighbors = [[i-1, j-1], [i-1, j], [i-1, j+1], [i, j-1], [i, j+1], [i+1, j-1], [i+1, j], [i+1, j+1]];\n    const possibleNeighbors = [[i-1, j], [i, j-1], [i, j+1], [i+1, j]];\n    var neighbors = [];\n    for (let k = 0; k < possibleNeighbors.length; k++) {\n        if (0 <= possibleNeighbors[k][0] && possibleNeighbors[k][0] < rows) {\n            if (0 <= possibleNeighbors[k][1] && possibleNeighbors[k][1] < cols) {\n                neighbors.push(possibleNeighbors[k]);\n            }\n        }\n    }\n    return neighbors;\n}\n\nexport function sameCoordinates(coor1, coor2) {\n    return (coor1[0]===coor2[0] && coor1[1]===coor2[1]);\n}\n\nexport function changeValue(dict, key, newValue) {\n    dict[key].value = newValue;\n}","import React from 'react';\nimport styles from \"./PathfindingVisualizer.module.scss\";\nimport { useState } from 'react';\nimport { Button } from '@material-ui/core';\nimport { search as BFS } from \"./SearchingAlgorithms/BFS\";\nimport { gridNeighbors } from \"./util\";\n\nconst ROWS = 15;\nconst COLUMNS = 38;\n\nexport const GOAL = 0;\nexport const ORIGIN = 1;\nexport const PATH = 2;\nexport const EXPLORED = 3;\nexport const FRONTIER = 4;\n\nconst ANIMATION_TIME = 10;\n\n\nconst Node = (props) => {\n    const [active, setActive] = useState(false);\n\n    const handleClick = () => {\n        props.onClick();\n        setActive(!active);\n    }\n\n    var color;\n    switch (props.value) {\n        case GOAL: color = \"green\"; break;\n        case ORIGIN: color = \"red\"; break;\n        case PATH: color = \"yellow\"; break;\n        case EXPLORED: color = \"purple\"; break;\n        case FRONTIER: color = \"#666\"; break;\n        default: color = \"white\"; break;\n    }\n\n    return (\n        <button \n            className={`${active? styles.nodeActive : styles.node}`} \n            // onClick={handleClick}\n            style={{\n                background: color\n            }}\n        />\n    );\n}\n  \nclass Board extends React.Component {\n    renderNode(i, j, key) {\n        return (\n            <Node \n                value={this.props.nodes[[i,j]].value} \n                // onClick={() => this.props.onClick(i, j)}\n                key={key}\n            />\n        );\n    }\n\n    render() {\n        var rows = [];\n        var key = 0;\n        for (let i = 0; i < this.props.rows; i++) {\n            var row = [];\n            for (let j = 0; j < this.props.columns; j++) {\n                row.push(this.renderNode(i, j, key++));\n            }\n            rows.push(<div className={styles.row} key={i}>{row}</div>);\n        }\n        return (\n            <div className=\"board\">\n                {rows}\n            </div>\n        );\n    }\n}\n\nexport default class PathfindingVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            nodes: generateGrid(ROWS, COLUMNS),\n            rows: ROWS,\n            columns: COLUMNS,\n\n            animating: false,\n        };\n\n        this.search = BFS;\n\n        this.history = [];\n        this.clearHistory = () => {\n            this.history = [];\n        }\n\n        this.timeoutIDArray = [];\n        this.clearTimeouts = () => {\n            for (let i = 0; i < this.timeoutIDArray.length; i++) {\n                clearTimeout(this.timeoutIDArray[i]);\n            }\n            this.timeoutIDArray = [];\n        }\n        this.resumePoint = 0;\n\n        this.takeSnapshot = (dict) => {\n            try {\n                this.history.push(copyDict(dict));\n            } catch (e) {\n                console.error(\"Error: takeSnapshot arguments are not well defined.\\n\", e);\n            }\n        }\n    }\n\n    componentDidMount() {\n    }\n\n    goToState(i) {\n        if (i < this.history.length) {\n            var displayState = this.history[i];\n            this.resumePoint = i;\n            this.setState({\n                nodes: displayState, \n                // highlights: {comparing: comparing}, \n            });\n        }\n    }\n\n    doSearch() {\n        this.clearTimeouts();\n        this.clearHistory();\n        var nodes = generateGrid(ROWS, COLUMNS);\n        this.search({nodes: nodes, takeSnapshot: this.takeSnapshot});\n        this.animateHistory(0);\n    }\n\n    animateHistory(startPoint) {\n        if (!startPoint) { startPoint = 0; }\n        if (this.startPoint >= this.history.length - 1) {\n            return;\n        }\n        this.setState({animating: true});\n        var pauseTime;\n        var count = 1;\n        for (let i = startPoint; i < this.history.length; i++) {\n            pauseTime = ANIMATION_TIME * count;\n            let timeoutID = setTimeout(() => {\n                this.goToState(i);\n                if (i === this.history.length - 1) { this.setState({animating: false}); }\n            }, pauseTime);\n\n            this.timeoutIDArray.push(timeoutID);\n            count++;\n        }\n    }\n\n    // handleClick(i, j) {\n    //     var grid = this.state.grid.slice();\n    //     grid[i][j] = 1;\n    //     this.setState({grid: grid});\n    // }\n\n    render() {\n        return (\n            <div>\n                <Board nodes={this.state.nodes} rows={this.state.rows} columns={this.state.columns} />\n                <button className={styles.test} onClick={()=>{ this.doSearch()}}>Test</button>\n            </div>\n        );\n    }\n}\n\nfunction generateGrid(rows, cols) {\n    var grid = {};\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            grid[[i,j]] = {\n                value: -1,\n                neighbors: gridNeighbors(i, j, rows, cols)\n            };\n        }\n    }\n    return grid;\n}\n\nfunction copyDict(dict) {\n    var newDict = {};\n    for (var node in dict) {\n        newDict[node] = {\n            value: dict[node].value,\n            // We don't use neighbors.slice() but actually use original neighbors on purpose\n            // because the neighbors of the nodes should stay consistent throughout searching\n            neighbors: dict[node].neighbors\n        }\n    }\n    return newDict;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport PathfindingVisualizer from './PathfindingVisualizer';\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}