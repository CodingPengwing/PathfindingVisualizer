{"version":3,"sources":["PathfindingVisualizer.module.scss","SearchingAlgorithms/BFS.js","util.js","PathfindingVisualizer.js","index.js"],"names":["module","exports","takeSnapshot","gridNeighbors","i","j","rows","cols","possibleNeighbors","neighbors","k","length","push","changeValue","dict","key","newValue","value","search","props","origin_c","goal_c","nodes","node","ORIGIN","GOAL","coor1","coor2","sameCoordinates","_c","frontier","explored","traverseFrom","shift","EXPLORED","neighbor","includes","goalTest","path","curr","PATH","FRONTIER","BFS","Node","color","useState","active","className","styles","nodeActive","style","background","Board","this","row","columns","renderNode","React","Component","PathfindingVisualizer","state","generateGrid","animating","history","clearHistory","timeoutIDArray","resumePoint","copyDict","e","console","error","displayState","setState","animateHistory","startPoint","count","timeoutID","setTimeout","goToState","test","onClick","doSearch","grid","newDict","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6423ca94.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"PathfindingVisualizer_node__29pS2\",\"nodeActive\":\"PathfindingVisualizer_nodeActive__1ryqb\",\"row\":\"PathfindingVisualizer_row__aIeZF\",\"test\":\"PathfindingVisualizer_test__34_BA\"};","import { ORIGIN, GOAL, FRONTIER, EXPLORED, PATH } from \"../PathfindingVisualizer\";\r\nimport { sameCoordinates, changeValue } from \"../util\";\r\nvar takeSnapshot;\r\n\r\nexport function search(props) {\r\n    const nodes = props.nodes;\r\n    takeSnapshot = props.takeSnapshot;\r\n    let origin_c;\r\n    let goal_c;\r\n\r\n    // Hard code for testing purposes\r\n    nodes[[5,5]].value = ORIGIN;\r\n    nodes[[14,25]].value = GOAL;\r\n    // ------------------------------\r\n\r\n    for (var node in nodes) {\r\n        if (nodes[node].value === ORIGIN) {\r\n            origin_c = node;\r\n        }\r\n        if (nodes[node].value === GOAL) {\r\n            goal_c = node;\r\n        }\r\n    }\r\n    if (origin_c && goal_c) {\r\n        BFS(nodes, origin_c, goal_c);\r\n    }\r\n}\r\n\r\nfunction BFS(nodes, origin_c, goal_c) {\r\n    takeSnapshot(nodes);\r\n\r\n    if (sameCoordinates(origin_c, goal_c)) {\r\n        return [origin_c];\r\n    }\r\n    var frontier = [], explored = [], traverseFrom = {};\r\n    frontier.push(\"\" + origin_c);\r\n    traverseFrom[\"\" + origin_c] = null;\r\n    takeSnapshot(nodes);\r\n\r\n    var _c, node;\r\n    while (true) {\r\n        // Failed to find the goal\r\n        if (!frontier.length) {\r\n            return [];\r\n        }\r\n        _c = frontier[0];\r\n        explored.push(_c);\r\n        frontier.shift();\r\n        if (_c !== \"\" + origin_c) {\r\n            changeValue(nodes, _c, EXPLORED);\r\n        }\r\n        takeSnapshot(nodes);\r\n\r\n        node = nodes[_c];\r\n        for (let i = 0; i < node.neighbors.length; i++) {\r\n            let neighbor = \"\" + node.neighbors[i];\r\n            if (!frontier.includes(neighbor) && !explored.includes(neighbor)) {\r\n                if (goalTest(nodes[neighbor])) {\r\n                    traverseFrom[neighbor] = _c;\r\n                    let path = [neighbor];\r\n                    let curr = neighbor;\r\n                    while (curr) {\r\n                        path.push(traverseFrom[curr]);\r\n                        curr = traverseFrom[curr];\r\n                        if (curr) {\r\n                            changeValue(nodes, curr, PATH);\r\n                            takeSnapshot(nodes);\r\n                        }\r\n                    }\r\n                    \r\n                    return path;\r\n                }\r\n                frontier.push(\"\" + neighbor);\r\n                traverseFrom[neighbor] = _c;\r\n                // console.log(traverseFrom);\r\n                changeValue(nodes, neighbor, FRONTIER);\r\n                takeSnapshot(nodes);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction goalTest(node) {\r\n    if (node.value === GOAL) { return true; }\r\n    return false;\r\n}\r\n","export function gridNeighbors(i, j, rows, cols) {\r\n    // const possibleNeighbors = [[i-1, j-1], [i-1, j], [i-1, j+1], [i, j-1], [i, j+1], [i+1, j-1], [i+1, j], [i+1, j+1]];\r\n    const possibleNeighbors = [[i-1, j], [i, j-1], [i, j+1], [i+1, j]];\r\n    var neighbors = [];\r\n    for (let k = 0; k < possibleNeighbors.length; k++) {\r\n        if (0 <= possibleNeighbors[k][0] && possibleNeighbors[k][0] < rows) {\r\n            if (0 <= possibleNeighbors[k][1] && possibleNeighbors[k][1] < cols) {\r\n                neighbors.push(possibleNeighbors[k]);\r\n            }\r\n        }\r\n    }\r\n    return neighbors;\r\n}\r\n\r\nexport function sameCoordinates(coor1, coor2) {\r\n    return (coor1[0]===coor2[0] && coor1[1]===coor2[1]);\r\n}\r\n\r\nexport function changeValue(dict, key, newValue) {\r\n    dict[key].value = newValue;\r\n}","import React from 'react';\r\nimport styles from \"./PathfindingVisualizer.module.scss\";\r\nimport { useState } from 'react';\r\nimport { Button } from '@material-ui/core';\r\nimport { search as BFS } from \"./SearchingAlgorithms/BFS\";\r\nimport { gridNeighbors } from \"./util\";\r\n\r\nconst ROWS = 15;\r\nconst COLUMNS = 38;\r\n\r\nexport const GOAL = 0;\r\nexport const ORIGIN = 1;\r\nexport const PATH = 2;\r\nexport const EXPLORED = 3;\r\nexport const FRONTIER = 4;\r\n\r\nconst ANIMATION_TIME = 10;\r\n\r\n\r\nconst Node = (props) => {\r\n    const [active, setActive] = useState(false);\r\n\r\n    const handleClick = () => {\r\n        props.onClick();\r\n        setActive(!active);\r\n    }\r\n\r\n    var color;\r\n    switch (props.value) {\r\n        case GOAL: color = \"green\"; break;\r\n        case ORIGIN: color = \"red\"; break;\r\n        case PATH: color = \"yellow\"; break;\r\n        case EXPLORED: color = \"purple\"; break;\r\n        case FRONTIER: color = \"#666\"; break;\r\n        default: color = \"white\"; break;\r\n    }\r\n\r\n    return (\r\n        <button \r\n            className={`${active? styles.nodeActive : styles.node}`} \r\n            // onClick={handleClick}\r\n            style={{\r\n                background: color\r\n            }}\r\n        />\r\n    );\r\n}\r\n  \r\nclass Board extends React.Component {\r\n    renderNode(i, j, key) {\r\n        return (\r\n            <Node \r\n                value={this.props.nodes[[i,j]].value} \r\n                // onClick={() => this.props.onClick(i, j)}\r\n                key={key}\r\n            />\r\n        );\r\n    }\r\n\r\n    render() {\r\n        var rows = [];\r\n        var key = 0;\r\n        for (let i = 0; i < this.props.rows; i++) {\r\n            var row = [];\r\n            for (let j = 0; j < this.props.columns; j++) {\r\n                row.push(this.renderNode(i, j, key++));\r\n            }\r\n            rows.push(<div className={styles.row} key={i}>{row}</div>);\r\n        }\r\n        return (\r\n            <div className=\"board\">\r\n                {rows}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default class PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            nodes: generateGrid(ROWS, COLUMNS),\r\n            rows: ROWS,\r\n            columns: COLUMNS,\r\n\r\n            animating: false,\r\n        };\r\n\r\n        this.search = BFS;\r\n\r\n        this.history = [];\r\n        this.clearHistory = () => {\r\n            this.history = [];\r\n        }\r\n\r\n        this.timeoutIDArray = [];\r\n        this.resumePoint = 0;\r\n\r\n        this.takeSnapshot = (dict) => {\r\n            try {\r\n                this.history.push(copyDict(dict));\r\n            } catch (e) {\r\n                console.error(\"Error: takeSnapshot arguments are not well defined.\\n\", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n    }\r\n\r\n    goToState(i) {\r\n        if (i < this.history.length) {\r\n            var displayState = this.history[i];\r\n            this.resumePoint = i;\r\n            this.setState({\r\n                nodes: displayState, \r\n                // highlights: {comparing: comparing}, \r\n            });\r\n        }\r\n    }\r\n\r\n    doSearch() {\r\n        this.search({nodes: copyDict(this.state.nodes), takeSnapshot: this.takeSnapshot});\r\n        this.animateHistory(0);\r\n    }\r\n\r\n    animateHistory(startPoint) {\r\n        if (!startPoint) { startPoint = 0; }\r\n        if (this.startPoint >= this.history.length - 1) {\r\n            return;\r\n        }\r\n        this.setState({animating: true});\r\n        var pauseTime;\r\n        var count = 1;\r\n        for (let i = startPoint; i < this.history.length; i++) {\r\n            pauseTime = ANIMATION_TIME * count;\r\n            let timeoutID = setTimeout(() => {\r\n                this.goToState(i);\r\n                if (i === this.history.length - 1) { this.setState({animating: false}); }\r\n            }, pauseTime);\r\n\r\n            this.timeoutIDArray.push(timeoutID);\r\n            count++;\r\n        }\r\n    }\r\n\r\n    // handleClick(i, j) {\r\n    //     var grid = this.state.grid.slice();\r\n    //     grid[i][j] = 1;\r\n    //     this.setState({grid: grid});\r\n    // }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Board nodes={this.state.nodes} rows={this.state.rows} columns={this.state.columns} />\r\n                <button className={styles.test} onClick={()=>{this.doSearch()}}>Test</button>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction generateGrid(rows, cols) {\r\n    var grid = {};\r\n    for (let i = 0; i < rows; i++) {\r\n        for (let j = 0; j < cols; j++) {\r\n            grid[[i,j]] = {\r\n                value: -1,\r\n                neighbors: gridNeighbors(i, j, rows, cols)\r\n            };\r\n        }\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction copyDict(dict) {\r\n    var newDict = {};\r\n    for (var node in dict) {\r\n        newDict[node] = {\r\n            value: dict[node].value,\r\n            // We don't use neighbors.slice() but actually use original neighbors on purpose\r\n            // because the neighbors of the nodes should stay consistent throughout searching\r\n            neighbors: dict[node].neighbors\r\n        }\r\n    }\r\n    return newDict;\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport PathfindingVisualizer from './PathfindingVisualizer';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <PathfindingVisualizer />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}